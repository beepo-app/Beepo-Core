'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var once = require('lodash.once');
var Prometheus = require('prom-client');
var merge = require('merge-options');
var requireOptional = require('optional');
var url = require('url');
var UrlValueParser = require('url-value-parser');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var once__default = /*#__PURE__*/_interopDefault(once);
var Prometheus__namespace = /*#__PURE__*/_interopNamespace(Prometheus);
var merge__default = /*#__PURE__*/_interopDefault(merge);
var requireOptional__default = /*#__PURE__*/_interopDefault(requireOptional);
var url__default = /*#__PURE__*/_interopDefault(url);
var UrlValueParser__default = /*#__PURE__*/_interopDefault(UrlValueParser);

const isRunningInKubernetes = () => Boolean(process.env.KUBERNETES_SERVICE_HOST);

//   This is the `globalRegistry` provided by the `prom-client`
//   We could create multiple registries with `new Prometheus.registry()`.

const defaultRegister = Prometheus__namespace.register;
const configure = once__default["default"](options => {
  const shouldSkipMetricsByEnvironment = options.detectKubernetes === true && !isRunningInKubernetes();

  if (!shouldSkipMetricsByEnvironment) {
    Prometheus__namespace.collectDefaultMetrics(options);
  }
});

const defaultHttpRequestDurationPercentilesInMillieconds = [0.5, 0.9, 0.95, 0.98, 0.99];
const defaultHttpRequestDurationInMilliseconds = [50, 100, 300, 500, 800, 1000, 1500, 2000, 3000, 5000, 10000];
const defaultHttpRequestDurationPercentileInSeconds = [0.5, 0.9, 0.95, 0.98, 0.99];
const defaultHttpRequestDurationInSeconds = [0.05, 0.1, 0.3, 0.5, 0.8, 1, 1.5, 2, 3, 10];
const defaultHttpContentLengthInBytes = [100000, 200000, 500000, 1000000, 1500000, 2000000, 3000000, 5000000, 10000000];
const defaultRequestLabels = ['path', 'status_code', 'method'];
const defaultGcLabels = ['gc_type'];

const asArray = maybeArray => Array.isArray(maybeArray) ? maybeArray : [maybeArray];

const shouldObserveMetricsInSeconds = options => options.accuracies.includes('s');

const shouldObserveMetricsInMilliseconds = options => options.accuracies.includes('ms');

const shouldObserveHttpRequestsAsSummary = options => options.metricTypes.includes('httpRequestsSummary');

const shouldObserveHttpRequestsAsHistogram = options => options.metricTypes.includes('httpRequestsHistogram');

const shouldObserveHttpRequestsAsCounter = options => options.metricTypes.includes('httpRequestsTotal');

const shouldObserveHttpContentLengthAsHistogram = options => options.metricTypes.includes('httpContentLengthHistogram');

const defaultOptions$1 = {
  getLabelValues: () => ({}),
  labels: [],
  accuracies: ['s'],
  metricPrefix: '',
  metricTypes: ['httpRequestsTotal', 'httpRequestsHistogram'],
  metricNames: {
    up: ['up'],
    countOfGcs: ['nodejs_gc_runs_total'],
    durationOfGc: ['nodejs_gc_pause_seconds_total'],
    reclaimedInGc: ['nodejs_gc_reclaimed_bytes_total'],
    httpRequestsTotal: ['http_requests_total'],
    httpRequestDurationPerPercentileInMilliseconds: ['http_request_duration_per_percentile_milliseconds'],
    httpRequestDurationPerPercentileInSeconds: ['http_request_duration_per_percentile_seconds'],
    httpRequestDurationInSeconds: ['http_request_duration_seconds'],
    httpRequestDurationInMilliseconds: ['http_request_duration_milliseconds'],
    httpRequestContentLengthInBytes: ['http_request_content_length_bytes'],
    httpResponseContentLengthInBytes: ['http_response_content_length_bytes']
  }
};

const getDefaultMetrics = options => ({
  up: asArray(options.metricNames.up).map(nameOfUpMetric => new Prometheus__namespace.Gauge({
    name: `${options.metricPrefix}${nameOfUpMetric}`,
    help: '1 = up, 0 = not up'
  })),
  countOfGcs: asArray(options.metricNames.countOfGcs).map(nameOfCountOfGcsMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfCountOfGcsMetric}`,
    help: 'Count of total garbage collections.',
    labelNames: defaultGcLabels
  })),
  durationOfGc: asArray(options.metricNames.durationOfGc).map(nameOfDurationOfGcMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfDurationOfGcMetric}`,
    help: 'Time spent in GC Pause in seconds.',
    labelNames: defaultGcLabels
  })),
  reclaimedInGc: asArray(options.metricNames.reclaimedInGc).map(nameOfReclaimedInGcMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfReclaimedInGcMetric}`,
    help: 'Total number of bytes reclaimed by GC.',
    labelNames: defaultGcLabels
  })),
  httpRequestContentLengthInBytes: shouldObserveHttpContentLengthAsHistogram(options) && asArray(options.metricNames.httpRequestContentLengthInBytes).map(nameOfHttpContentLengthMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpContentLengthMetric}`,
    help: 'The HTTP request content length in bytes.',
    labelNames: defaultRequestLabels.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpContentLengthInBytes
  })),
  httpResponseContentLengthInBytes: shouldObserveHttpContentLengthAsHistogram(options) && asArray(options.metricNames.httpResponseContentLengthInBytes).map(nameOfHttpContentLengthMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpContentLengthMetric}`,
    help: 'The HTTP response content length in bytes.',
    labelNames: defaultRequestLabels.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpContentLengthInBytes
  }))
});

const getHttpRequestLatencyMetricsInMilliseconds = options => ({
  httpRequestDurationPerPercentileInMilliseconds: shouldObserveHttpRequestsAsSummary(options) && asArray(options.metricNames.httpRequestDurationPerPercentileInMilliseconds).map(nameOfHttpRequestDurationPerPercentileInMillisecondsMetric => new Prometheus__namespace.Summary({
    name: `${options.metricPrefix}${nameOfHttpRequestDurationPerPercentileInMillisecondsMetric}`,
    help: 'The HTTP request latencies in milliseconds.',
    labelNames: defaultRequestLabels.concat(options.labels).sort(),
    percentiles: options.percentiles || defaultHttpRequestDurationPercentilesInMillieconds
  })),
  httpRequestDurationInMilliseconds: shouldObserveHttpRequestsAsHistogram(options) && asArray(options.metricNames.httpRequestDurationInMilliseconds).map(nameOfHttpRequestDurationInMillisecondsMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpRequestDurationInMillisecondsMetric}`,
    help: 'The HTTP request latencies in milliseconds.',
    labelNames: defaultRequestLabels.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpRequestDurationInMilliseconds
  }))
});

const getHttpRequestLatencyMetricsInSeconds = options => ({
  httpRequestDurationPerPercentileInSeconds: shouldObserveHttpRequestsAsSummary(options) && asArray(options.metricNames.httpRequestDurationPerPercentileInSeconds).map(nameOfHttpRequestDurationPerPercentileInSeconds => new Prometheus__namespace.Summary({
    name: `${options.metricPrefix}${nameOfHttpRequestDurationPerPercentileInSeconds}`,
    help: 'The HTTP request latencies in seconds.',
    labelNames: defaultRequestLabels.concat(options.labels).sort(),
    percentiles: options.percentiles || defaultHttpRequestDurationPercentileInSeconds
  })),
  httpRequestDurationInSeconds: shouldObserveHttpRequestsAsHistogram(options) && asArray(options.metricNames.httpRequestDurationInSeconds).map(nameOfHttpRequestDurationInSecondsMetric => new Prometheus__namespace.Histogram({
    name: `${options.metricPrefix}${nameOfHttpRequestDurationInSecondsMetric}`,
    help: 'The HTTP request latencies in seconds.',
    labelNames: defaultRequestLabels.concat(options.labels).sort(),
    buckets: options.buckets || defaultHttpRequestDurationInSeconds
  }))
});

const getHttpRequestCounterMetric = options => ({
  httpRequestsTotal: shouldObserveHttpRequestsAsCounter(options) && asArray(options.metricNames.httpRequestsTotal).map(nameOfHttpRequestsTotalMetric => new Prometheus__namespace.Counter({
    name: `${options.metricPrefix}${nameOfHttpRequestsTotalMetric}`,
    help: 'The total HTTP requests.',
    labelNames: defaultRequestLabels.concat(options.labels).sort()
  }))
});

const createMetricTypes = options => {
  const defaultedOptions = merge__default["default"](defaultOptions$1, options);
  configure({
    prefix: defaultedOptions.metricPrefix
  });
  const defaultMetrics = getDefaultMetrics(defaultedOptions);
  const httpRequestLatencyMetricsInMilliseconds = shouldObserveMetricsInMilliseconds(defaultedOptions) && getHttpRequestLatencyMetricsInMilliseconds(defaultedOptions);
  const httpRequestLatencyMetricsInSeconds = shouldObserveMetricsInSeconds(defaultedOptions) && getHttpRequestLatencyMetricsInSeconds(defaultedOptions);
  const httpRequestCounterMetric = getHttpRequestCounterMetric(defaultedOptions);
  return Object.assign({}, defaultMetrics, httpRequestLatencyMetricsInMilliseconds, httpRequestLatencyMetricsInSeconds, httpRequestCounterMetric);
};

createMetricTypes.defaultOptions = defaultOptions$1;

const getSummary = async () => defaultRegister.metrics();

const getContentType = () => defaultRegister.contentType;

const NS_PER_SEC = 1e9;
const NS_PER_MS = 1e6;

const sortLabels = unsortedLabels => Object.keys(unsortedLabels).sort((a, b) => {
  if (a < b) {
    return -1;
  }

  if (a > b) {
    return 1;
  }

  return 0;
}).reduce((sortedLabels, labelName) => {
  sortedLabels[labelName] = unsortedLabels[labelName];
  return sortedLabels;
}, {});

const endMeasurementFrom = start => {
  const [seconds, nanoseconds] = process.hrtime(start);
  return {
    durationMs: Math.round((seconds * NS_PER_SEC + nanoseconds) / NS_PER_MS),
    durationS: (seconds * NS_PER_SEC + nanoseconds) / NS_PER_SEC
  };
};

const shouldObserveMetricType = metricType => options => {
  var _options$metricTypes;

  return (_options$metricTypes = options.metricTypes) === null || _options$metricTypes === void 0 ? void 0 : _options$metricTypes.includes(metricType);
};

const shouldObserveMetricAccuracy = accuracy => options => {
  var _options$accuracies;

  return (_options$accuracies = options.accuracies) === null || _options$accuracies === void 0 ? void 0 : _options$accuracies.includes(accuracy);
};

const defaultOptions = {
  accuracies: ['s'],
  metricTypes: ['httpRequestsTotal', 'httpRequestsHistogram'],
  skip: () => false,
  detectKubernetes: false
};

const createRequestRecorder = (metricTypes, options = defaultOptions) => {
  const defaultedRecorderOptions = merge__default["default"](defaultOptions, options);
  const shouldSkipMetricsByEnvironment = defaultedRecorderOptions.detectKubernetes && !isRunningInKubernetes();
  const shouldObserveInSeconds = shouldObserveMetricAccuracy('s')(defaultedRecorderOptions);
  const shouldObserveInMilliseconds = shouldObserveMetricAccuracy('ms')(defaultedRecorderOptions);
  const shouldObserveInSummary = shouldObserveMetricType('httpRequestsSummary')(defaultedRecorderOptions);
  const shouldObserveInHistogram = shouldObserveMetricType('httpRequestsHistogram')(defaultedRecorderOptions);
  const shouldObserveInCounter = shouldObserveMetricType('httpRequestsTotal')(defaultedRecorderOptions);
  const shouldObserveContentLengthInHistogram = shouldObserveMetricType('httpContentLengthHistogram')(defaultedRecorderOptions); // eslint-disable-next-line complexity

  return (start, recordingOptions) => {
    const {
      durationMs,
      durationS
    } = endMeasurementFrom(start);
    const labels = sortLabels(recordingOptions.labels);

    if (shouldObserveInMilliseconds && shouldObserveInHistogram && !shouldSkipMetricsByEnvironment) {
      metricTypes.httpRequestDurationInMilliseconds.forEach(httpRequestDurationInMillisecondsMetricType => {
        httpRequestDurationInMillisecondsMetricType.observe(labels, durationMs);
      });
    }

    if (shouldObserveInMilliseconds && shouldObserveInSummary && !shouldSkipMetricsByEnvironment) {
      metricTypes.httpRequestDurationPerPercentileInMilliseconds.forEach(httpRequestDurationPerPercentileInMillisecondsMetricType => {
        httpRequestDurationPerPercentileInMillisecondsMetricType.observe(labels, durationMs);
      });
    }

    if (shouldObserveInSeconds && shouldObserveInHistogram && !shouldSkipMetricsByEnvironment) {
      metricTypes.httpRequestDurationInSeconds.forEach(httpRequestDurationInSecondsMetricType => {
        httpRequestDurationInSecondsMetricType.observe(labels, durationS);
      });
    }

    if (shouldObserveInSeconds && shouldObserveInSummary && !shouldSkipMetricsByEnvironment) {
      metricTypes.httpRequestDurationPerPercentileInSeconds.forEach(httpRequestDurationPerPercentileInSecondsMetricType => {
        httpRequestDurationPerPercentileInSecondsMetricType.observe(labels, durationS);
      });
    }

    if (shouldObserveInCounter && !shouldSkipMetricsByEnvironment) {
      metricTypes.httpRequestsTotal.forEach(httpRequestsTotalMetricType => {
        httpRequestsTotalMetricType.inc(labels);
      });
    }

    if (!shouldSkipMetricsByEnvironment && shouldObserveContentLengthInHistogram && recordingOptions.requestContentLength) {
      metricTypes.httpRequestContentLengthInBytes.forEach(httpRequestContentLengthInBytesMetricType => {
        httpRequestContentLengthInBytesMetricType.observe(labels, // @ts-expect-error
        recordingOptions.requestContentLength);
      });
    }

    if (!shouldSkipMetricsByEnvironment && shouldObserveContentLengthInHistogram && recordingOptions.responseContentLength) {
      metricTypes.httpResponseContentLengthInBytes.forEach(httpResponseContentLengthInBytesMetricType => {
        httpResponseContentLengthInBytesMetricType.observe(labels, // @ts-expect-error
        recordingOptions.responseContentLength);
      });
    }
  };
};

createRequestRecorder.defaultOptions = defaultOptions;

const gc = requireOptional__default["default"]('@sematext/gc-stats');
const gcTypes = {
  0: 'unknown',
  1: 'scavenge',
  2: 'mark_sweep_compact',
  3: 'scavenge_and_mark_sweep_compact',
  4: 'incremental_marking',
  8: 'weak_phantom',
  15: 'all'
};
const createGcObserver = once__default["default"](metricTypes => () => {
  if (typeof gc !== 'function') {
    return;
  }

  gc().on('stats', stats => {
    const gcType = gcTypes[stats.gctype];
    metricTypes.countOfGcs.forEach(countOfGcMetricType => {
      countOfGcMetricType.labels(gcType).inc();
    });
    metricTypes.durationOfGc.forEach(durationOfGcMetricType => {
      durationOfGcMetricType.labels(gcType).inc(stats.pause / 1e9);
    });

    if (stats.diff.usedHeapSize < 0) {
      metricTypes.reclaimedInGc.forEach(reclaimedInGcMetricType => {
        reclaimedInGcMetricType.labels(gcType).inc(stats.diff.usedHeapSize * -1);
      });
    }
  });
});

const normalizeStatusCode = statusCode => statusCode;

const urlValueParser = new UrlValueParser__default["default"]();

const normalizePath = path => urlValueParser.replacePathValues(url__default["default"].parse(path).pathname);

const normalizeMethod = method => method.toLowerCase();

const defaultNormalizers = {
  normalizeStatusCode,
  normalizePath,
  normalizeMethod
};

exports.Prometheus = Prometheus__namespace;
exports.createGcObserver = createGcObserver;
exports.createMetricTypes = createMetricTypes;
exports.createRequestRecorder = createRequestRecorder;
exports.defaultNormalizers = defaultNormalizers;
exports.defaultRegister = defaultRegister;
exports.getContentType = getContentType;
exports.getSummary = getSummary;
exports.isRunningInKubernetes = isRunningInKubernetes;
exports.normalizeMethod = normalizeMethod;
exports.normalizePath = normalizePath;
exports.normalizeStatusCode = normalizeStatusCode;
