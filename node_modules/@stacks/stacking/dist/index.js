"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackingClient = void 0;
const common_1 = require("@stacks/common");
const transactions_1 = require("@stacks/transactions");
const bn_js_1 = __importDefault(require("bn.js"));
const constants_1 = require("./constants");
const common_2 = require("@stacks/common");
const utils_1 = require("./utils");
__exportStar(require("./utils"), exports);
class StackingClient {
    constructor(address, network) {
        this.address = address;
        this.network = network;
    }
    async getCoreInfo() {
        const url = this.network.getInfoUrl();
        return common_2.fetchPrivate(url).then(res => res.json());
    }
    async getPoxInfo() {
        const url = this.network.getPoxInfoUrl();
        return common_2.fetchPrivate(url).then(res => res.json());
    }
    async getTargetBlockTime() {
        const url = this.network.getBlockTimeInfoUrl();
        const res = await common_2.fetchPrivate(url).then(res => res.json());
        if (this.network.isMainnet()) {
            return res.mainnet.target_block_time;
        }
        else {
            return res.testnet.target_block_time;
        }
    }
    async getAccountStatus() {
        const url = this.network.getAccountApiUrl(this.address);
        return common_2.fetchPrivate(url).then(res => res.json());
    }
    async getAccountBalance() {
        return this.getAccountStatus().then(res => {
            return BigInt(res.balance);
        });
    }
    async getCycleDuration() {
        const poxInfoPromise = this.getPoxInfo();
        const targetBlockTimePromise = await this.getTargetBlockTime();
        return Promise.all([poxInfoPromise, targetBlockTimePromise]).then(([poxInfo, targetBlockTime]) => {
            return poxInfo.reward_cycle_length * targetBlockTime;
        });
    }
    async getRewardsTotalForBtcAddress() {
        const url = this.network.getRewardsTotalUrl(this.address);
        return common_2.fetchPrivate(url).then(res => res.json());
    }
    async getRewardsForBtcAddress(options) {
        const url = `${this.network.getRewardsUrl(this.address, options)}`;
        return common_2.fetchPrivate(url).then(res => res.json());
    }
    async getRewardHoldersForBtcAddress(options) {
        const url = `${this.network.getRewardHoldersUrl(this.address, options)}`;
        return common_2.fetchPrivate(url).then(res => res.json());
    }
    async getSecondsUntilNextCycle() {
        const poxInfoPromise = this.getPoxInfo();
        const targetBlockTimePromise = await this.getTargetBlockTime();
        const coreInfoPromise = this.getCoreInfo();
        return Promise.all([poxInfoPromise, targetBlockTimePromise, coreInfoPromise]).then(([poxInfo, targetBlockTime, coreInfo]) => {
            const blocksToNextCycle = poxInfo.reward_cycle_length -
                ((coreInfo.burn_block_height - poxInfo.first_burnchain_block_height) %
                    poxInfo.reward_cycle_length);
            return blocksToNextCycle * targetBlockTime;
        });
    }
    async isStackingEnabledNextCycle() {
        return (await this.getPoxInfo()).rejection_votes_left_required > 0;
    }
    async hasMinimumStx() {
        const balance = await this.getAccountBalance();
        const min = BigInt((await this.getPoxInfo()).min_amount_ustx);
        return balance >= min;
    }
    async canStack({ poxAddress, cycles }) {
        const balancePromise = this.getAccountBalance();
        const poxInfoPromise = this.getPoxInfo();
        return Promise.all([balancePromise, poxInfoPromise])
            .then(([balance, poxInfo]) => {
            const { hashMode, data } = utils_1.decodeBtcAddress(poxAddress);
            const hashModeBuffer = transactions_1.bufferCV(new bn_js_1.default(hashMode, 10).toArrayLike(common_1.Buffer));
            const hashbytes = transactions_1.bufferCV(data);
            const poxAddressCV = transactions_1.tupleCV({
                hashbytes,
                version: hashModeBuffer,
            });
            const [contractAddress, contractName] = this.parseContractId(poxInfo.contract_id);
            return transactions_1.callReadOnlyFunction({
                network: this.network,
                contractName,
                contractAddress,
                functionName: 'can-stack-stx',
                senderAddress: this.address,
                functionArgs: [
                    poxAddressCV,
                    transactions_1.uintCV(balance.toString()),
                    transactions_1.uintCV(poxInfo.reward_cycle_id),
                    transactions_1.uintCV(cycles.toString()),
                ],
            });
        })
            .then((responseCV) => {
            if (responseCV.type === transactions_1.ClarityType.ResponseOk) {
                return {
                    eligible: true,
                };
            }
            else {
                const errorCV = responseCV;
                return {
                    eligible: false,
                    reason: constants_1.StackingErrors[+transactions_1.cvToString(errorCV.value)],
                };
            }
        });
    }
    async stack({ amountMicroStx, poxAddress, cycles, privateKey, burnBlockHeight, }) {
        const poxInfo = await this.getPoxInfo();
        const contract = poxInfo.contract_id;
        const txOptions = this.getStackOptions({
            amountMicroStx,
            cycles,
            poxAddress,
            contract,
            burnBlockHeight,
        });
        const tx = await transactions_1.makeContractCall(Object.assign(Object.assign({}, txOptions), { senderKey: privateKey }));
        return transactions_1.broadcastTransaction(tx, txOptions.network);
    }
    async delegateStx({ amountMicroStx, delegateTo, untilBurnBlockHeight, poxAddress, privateKey, }) {
        const poxInfo = await this.getPoxInfo();
        const contract = poxInfo.contract_id;
        const txOptions = this.getDelegateOptions({
            contract,
            amountMicroStx,
            delegateTo,
            untilBurnBlockHeight,
            poxAddress,
        });
        const tx = await transactions_1.makeContractCall(Object.assign(Object.assign({}, txOptions), { senderKey: privateKey }));
        return transactions_1.broadcastTransaction(tx, txOptions.network);
    }
    async delegateStackStx({ stacker, amountMicroStx, poxAddress, burnBlockHeight, cycles, privateKey, nonce, }) {
        const poxInfo = await this.getPoxInfo();
        const contract = poxInfo.contract_id;
        const txOptions = this.getDelegateStackOptions({
            contract,
            stacker,
            amountMicroStx,
            poxAddress,
            burnBlockHeight,
            cycles,
            nonce,
        });
        const tx = await transactions_1.makeContractCall(Object.assign(Object.assign({}, txOptions), { senderKey: privateKey }));
        return transactions_1.broadcastTransaction(tx, txOptions.network);
    }
    async stackAggregationCommit({ poxAddress, rewardCycle, privateKey, }) {
        const poxInfo = await this.getPoxInfo();
        const contract = poxInfo.contract_id;
        const txOptions = this.getStackAggregationCommitOptions({
            contract,
            poxAddress,
            rewardCycle,
        });
        const tx = await transactions_1.makeContractCall(Object.assign(Object.assign({}, txOptions), { senderKey: privateKey }));
        return transactions_1.broadcastTransaction(tx, txOptions.network);
    }
    async revokeDelegateStx(privateKey) {
        const poxInfo = await this.getPoxInfo();
        const contract = poxInfo.contract_id;
        const txOptions = this.getRevokeDelegateStxOptions(contract);
        const tx = await transactions_1.makeContractCall(Object.assign(Object.assign({}, txOptions), { senderKey: privateKey }));
        return transactions_1.broadcastTransaction(tx, txOptions.network);
    }
    getStackOptions({ amountMicroStx, poxAddress, cycles, contract, burnBlockHeight, }) {
        const { hashMode, data } = utils_1.decodeBtcAddress(poxAddress);
        const hashModeBuffer = transactions_1.bufferCV(new bn_js_1.default(hashMode, 10).toArrayLike(common_1.Buffer));
        const hashbytes = transactions_1.bufferCV(data);
        const address = transactions_1.tupleCV({
            hashbytes,
            version: hashModeBuffer,
        });
        const [contractAddress, contractName] = this.parseContractId(contract);
        const network = this.network;
        const txOptions = {
            contractAddress,
            contractName,
            functionName: 'stack-stx',
            functionArgs: [transactions_1.uintCV(amountMicroStx), address, transactions_1.uintCV(burnBlockHeight), transactions_1.uintCV(cycles)],
            validateWithAbi: true,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
        };
        return txOptions;
    }
    getDelegateOptions({ contract, amountMicroStx, delegateTo, untilBurnBlockHeight, poxAddress, }) {
        let address = undefined;
        if (poxAddress) {
            const { hashMode, data } = utils_1.decodeBtcAddress(poxAddress);
            const hashModeBuffer = transactions_1.bufferCV(new bn_js_1.default(hashMode, 10).toArrayLike(common_1.Buffer));
            const hashbytes = transactions_1.bufferCV(data);
            address = transactions_1.someCV(transactions_1.tupleCV({
                hashbytes,
                version: hashModeBuffer,
            }));
        }
        const [contractAddress, contractName] = this.parseContractId(contract);
        const network = this.network;
        const txOptions = {
            contractAddress,
            contractName,
            functionName: 'delegate-stx',
            functionArgs: [
                transactions_1.uintCV(amountMicroStx),
                transactions_1.standardPrincipalCV(delegateTo),
                untilBurnBlockHeight ? transactions_1.someCV(transactions_1.uintCV(untilBurnBlockHeight)) : transactions_1.noneCV(),
                address ? address : transactions_1.noneCV(),
            ],
            validateWithAbi: true,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
        };
        return txOptions;
    }
    getDelegateStackOptions({ contract, stacker, amountMicroStx, poxAddress, burnBlockHeight, cycles, nonce, }) {
        const { hashMode, data } = utils_1.decodeBtcAddress(poxAddress);
        const hashModeBuffer = transactions_1.bufferCV(new bn_js_1.default(hashMode, 10).toArrayLike(common_1.Buffer));
        const hashbytes = transactions_1.bufferCV(data);
        const address = transactions_1.tupleCV({
            hashbytes,
            version: hashModeBuffer,
        });
        const [contractAddress, contractName] = this.parseContractId(contract);
        const network = this.network;
        const txOptions = {
            contractAddress,
            contractName,
            functionName: 'delegate-stack-stx',
            functionArgs: [
                transactions_1.standardPrincipalCV(stacker),
                transactions_1.uintCV(amountMicroStx),
                address,
                transactions_1.uintCV(burnBlockHeight),
                transactions_1.uintCV(cycles),
            ],
            validateWithAbi: true,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
        };
        if (nonce) {
            txOptions.nonce = nonce;
        }
        return txOptions;
    }
    getStackAggregationCommitOptions({ contract, poxAddress, rewardCycle, }) {
        const { hashMode, data } = utils_1.decodeBtcAddress(poxAddress);
        const hashModeBuffer = transactions_1.bufferCV(new bn_js_1.default(hashMode, 10).toArrayLike(common_1.Buffer));
        const hashbytes = transactions_1.bufferCV(data);
        const address = transactions_1.tupleCV({
            hashbytes,
            version: hashModeBuffer,
        });
        const [contractAddress, contractName] = this.parseContractId(contract);
        const network = this.network;
        const txOptions = {
            contractAddress,
            contractName,
            functionName: 'stack-aggregation-commit',
            functionArgs: [address, transactions_1.uintCV(rewardCycle)],
            validateWithAbi: true,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
        };
        return txOptions;
    }
    getRevokeDelegateStxOptions(contract) {
        const [contractAddress, contractName] = this.parseContractId(contract);
        const network = this.network;
        const txOptions = {
            contractAddress,
            contractName,
            functionName: 'revoke-delegate-stx',
            functionArgs: [],
            validateWithAbi: true,
            network,
            anchorMode: transactions_1.AnchorMode.Any,
        };
        return txOptions;
    }
    async getStatus() {
        const poxInfo = await this.getPoxInfo();
        const [contractAddress, contractName] = this.parseContractId(poxInfo.contract_id);
        const account = await this.getAccountStatus();
        const functionName = 'get-stacker-info';
        return transactions_1.callReadOnlyFunction({
            contractAddress,
            contractName,
            functionName,
            senderAddress: this.address,
            functionArgs: [transactions_1.standardPrincipalCV(this.address)],
            network: this.network,
        }).then((responseCV) => {
            if (responseCV.type === transactions_1.ClarityType.OptionalSome) {
                const someCV = responseCV;
                const tupleCV = someCV.value;
                const poxAddress = tupleCV.data['pox-addr'];
                const amountMicroStx = tupleCV.data['amount-ustx'];
                const firstRewardCycle = tupleCV.data['first-reward-cycle'];
                const lockPeriod = tupleCV.data['lock-period'];
                const version = poxAddress.data['version'];
                const hashbytes = poxAddress.data['hashbytes'];
                return {
                    stacked: true,
                    details: {
                        amount_microstx: amountMicroStx.value.toString(),
                        first_reward_cycle: Number(firstRewardCycle.value),
                        lock_period: Number(lockPeriod.value),
                        unlock_height: account.unlock_height,
                        pox_address: {
                            version: version.buffer,
                            hashbytes: hashbytes.buffer,
                        },
                    },
                };
            }
            else if (responseCV.type === transactions_1.ClarityType.OptionalNone) {
                return {
                    stacked: false,
                };
            }
            else {
                throw new Error(`Error fetching stacker info`);
            }
        });
    }
    modifyLockTxFee({ tx, amountMicroStx }) {
        const fee = tx.auth.getFee();
        tx.payload.functionArgs[0] = transactions_1.uintCV(common_1.intToBigInt(amountMicroStx, false) - fee);
        return tx;
    }
    parseContractId(contract) {
        const parts = contract.split('.');
        if (parts.length !== 2 || !transactions_1.validateStacksAddress(parts[0]) || parts[1] !== 'pox') {
            throw new Error('Stacking contract ID is malformed');
        }
        return parts;
    }
}
exports.StackingClient = StackingClient;
//# sourceMappingURL=index.js.map