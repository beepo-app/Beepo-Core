"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorString = exports.getBTCAddress = exports.poxAddressToBtcAddress = exports.extractPoxAddressFromClarityValue = exports.decodeBtcAddress = exports.getAddressHashMode = exports.hashModeToBtcAddressVersion = exports.btcAddressVersionToHashMode = exports.BitcoinNetworkVersion = exports.InvalidAddressError = void 0;
const transactions_1 = require("@stacks/transactions");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const bn_js_1 = __importDefault(require("bn.js"));
const constants_1 = require("./constants");
class InvalidAddressError extends Error {
    constructor(address, innerError) {
        const msg = `${address} is not a valid P2PKH or P2SH address -- native P2WPKH and native P2WSH are not supported in PoX.`;
        super(msg);
        this.message = msg;
        this.name = this.constructor.name;
        this.innerError = innerError;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
exports.InvalidAddressError = InvalidAddressError;
exports.BitcoinNetworkVersion = {
    mainnet: {
        P2PKH: 0x00,
        P2SH: 0x05,
    },
    testnet: {
        P2PKH: 0x6f,
        P2SH: 0xc4,
    },
};
function btcAddressVersionToHashMode(btcAddressVersion) {
    switch (btcAddressVersion) {
        case exports.BitcoinNetworkVersion.mainnet.P2PKH:
            return transactions_1.AddressHashMode.SerializeP2PKH;
        case exports.BitcoinNetworkVersion.testnet.P2PKH:
            return transactions_1.AddressHashMode.SerializeP2PKH;
        case exports.BitcoinNetworkVersion.mainnet.P2SH:
            return transactions_1.AddressHashMode.SerializeP2SH;
        case exports.BitcoinNetworkVersion.testnet.P2SH:
            return transactions_1.AddressHashMode.SerializeP2SH;
        default:
            throw new Error('Invalid pox address version');
    }
}
exports.btcAddressVersionToHashMode = btcAddressVersionToHashMode;
function hashModeToBtcAddressVersion(hashMode, network) {
    if (!['mainnet', 'testnet'].includes(network)) {
        throw new Error(`Invalid network argument: ${network}`);
    }
    switch (hashMode) {
        case transactions_1.AddressHashMode.SerializeP2PKH:
            return exports.BitcoinNetworkVersion[network].P2PKH;
        case transactions_1.AddressHashMode.SerializeP2SH:
            return exports.BitcoinNetworkVersion[network].P2SH;
        default:
            throw new Error(`Invalid pox address hash mode: ${hashMode}`);
    }
}
exports.hashModeToBtcAddressVersion = hashModeToBtcAddressVersion;
function getAddressHashMode(btcAddress) {
    try {
        const { version } = bitcoinjs_lib_1.address.fromBase58Check(btcAddress);
        return btcAddressVersionToHashMode(version);
    }
    catch (error) {
        throw new InvalidAddressError(btcAddress, error);
    }
}
exports.getAddressHashMode = getAddressHashMode;
function decodeBtcAddress(btcAddress) {
    let b58Result;
    try {
        b58Result = bitcoinjs_lib_1.address.fromBase58Check(btcAddress);
    }
    catch (error) {
        throw new InvalidAddressError(btcAddress, error);
    }
    const hashMode = btcAddressVersionToHashMode(b58Result.version);
    return {
        hashMode,
        data: b58Result.hash,
    };
}
exports.decodeBtcAddress = decodeBtcAddress;
function extractPoxAddressFromClarityValue(poxAddrClarityValue) {
    const clarityValue = poxAddrClarityValue;
    if (clarityValue.type !== transactions_1.ClarityType.Tuple || !clarityValue.data) {
        throw new Error('Invalid argument, expected ClarityValue to be a TupleCV');
    }
    if (!('version' in clarityValue.data) || !('hashbytes' in clarityValue.data)) {
        throw new Error('Invalid argument, expected Clarity tuple value to contain `version` and `hashbytes` keys');
    }
    const versionCV = clarityValue.data['version'];
    const hashBytesCV = clarityValue.data['hashbytes'];
    if (versionCV.type !== transactions_1.ClarityType.Buffer || hashBytesCV.type !== transactions_1.ClarityType.Buffer) {
        throw new Error('Invalid argument, expected Clarity tuple value to contain `version` and `hashbytes` buffers');
    }
    return {
        version: versionCV.buffer,
        hashBytes: hashBytesCV.buffer,
    };
}
exports.extractPoxAddressFromClarityValue = extractPoxAddressFromClarityValue;
function poxAddressToBtcAddress(...args) {
    let version, hashBytes, network;
    if (args.length === 3) {
        [version, hashBytes, network] = args;
    }
    else if (args.length === 2) {
        ({ version, hashBytes } = extractPoxAddressFromClarityValue(args[0]));
        network = args[1];
    }
    else {
        throw new Error('Invalid arguments');
    }
    if (version.byteLength !== 1) {
        throw new Error(`Invalid byte length for version buffer: ${version.toString('hex')}`);
    }
    if (hashBytes.byteLength !== 20) {
        throw new Error(`Invalid byte length for hashBytes: ${hashBytes.toString('hex')}`);
    }
    const btcNetworkVersion = hashModeToBtcAddressVersion(version[0], network);
    const btcAddress = bitcoinjs_lib_1.address.toBase58Check(hashBytes, btcNetworkVersion);
    return btcAddress;
}
exports.poxAddressToBtcAddress = poxAddressToBtcAddress;
function getBTCAddress(version, checksum) {
    const btcAddress = bitcoinjs_lib_1.address.toBase58Check(checksum, new bn_js_1.default(version).toNumber());
    return btcAddress;
}
exports.getBTCAddress = getBTCAddress;
function getErrorString(error) {
    switch (error) {
        case constants_1.StackingErrors.ERR_STACKING_UNREACHABLE:
            return 'Stacking unreachable';
        case constants_1.StackingErrors.ERR_STACKING_INSUFFICIENT_FUNDS:
            return 'Insufficient funds';
        case constants_1.StackingErrors.ERR_STACKING_INVALID_LOCK_PERIOD:
            return 'Invalid lock period';
        case constants_1.StackingErrors.ERR_STACKING_ALREADY_STACKED:
            return 'Account already stacked. Concurrent stacking not allowed.';
        case constants_1.StackingErrors.ERR_STACKING_NO_SUCH_PRINCIPAL:
            return 'Principal does not exist';
        case constants_1.StackingErrors.ERR_STACKING_EXPIRED:
            return 'Stacking expired';
        case constants_1.StackingErrors.ERR_STACKING_STX_LOCKED:
            return 'STX balance is locked';
        case constants_1.StackingErrors.ERR_STACKING_PERMISSION_DENIED:
            return 'Permission denied';
        case constants_1.StackingErrors.ERR_STACKING_THRESHOLD_NOT_MET:
            return 'Stacking threshold not met';
        case constants_1.StackingErrors.ERR_STACKING_POX_ADDRESS_IN_USE:
            return 'PoX address already in use';
        case constants_1.StackingErrors.ERR_STACKING_INVALID_POX_ADDRESS:
            return 'Invalid PoX address';
        case constants_1.StackingErrors.ERR_STACKING_ALREADY_REJECTED:
            return 'Stacking already rejected';
        case constants_1.StackingErrors.ERR_STACKING_INVALID_AMOUNT:
            return 'Invalid amount';
        case constants_1.StackingErrors.ERR_NOT_ALLOWED:
            return 'Stacking not allowed';
        case constants_1.StackingErrors.ERR_STACKING_ALREADY_DELEGATED:
            return 'Already delegated';
        case constants_1.StackingErrors.ERR_DELEGATION_EXPIRES_DURING_LOCK:
            return 'Delegation expires during lock period';
        case constants_1.StackingErrors.ERR_DELEGATION_TOO_MUCH_LOCKED:
            return 'Delegation too much locked';
        case constants_1.StackingErrors.ERR_DELEGATION_POX_ADDR_REQUIRED:
            return 'PoX address required for delegation';
        case constants_1.StackingErrors.ERR_INVALID_START_BURN_HEIGHT:
            return 'Invalid start burn height';
    }
}
exports.getErrorString = getErrorString;
//# sourceMappingURL=utils.js.map